// jQuery Mask Plugin
// 安恒LIMS开发
(function ($) {
    "use strict";
    var mask_exec = function (value, cellSet) {
        value = String(value);
        $.isNumeric(cellSet.mask) && (
            cellSet.blws = [[0, parseInt(cellSet.mask)]]
        );
        if (value.substr(0, 1) != '=') {
            if ($.isNumeric(cellSet.mask)) {
                value = '' === value ? '' : auto_round(value, cellSet);
            } else if ('round_hyd_vd0' == cellSet.mask) {
                var opt = cellSet.maskOptions || {};
                value = round_hyd_vd0(value, opt.lineIndex, opt.cellId);
            }
        }
        return value;
    }
    var Mask = function (editor, cellSet) {
        if (typeof editor != 'object') {
            // 直接进行修约
            return mask_exec(editor, cellSet);
        } else {
            $(editor).focus(function () {
                setTimeout(function () {
                    var value = $(editor).val();
                    // 给计算公式的各个参数高亮显示虚边线
                    if (value.indexOf('=') > -1) {
                        var formula = value;
                        var regex = /([A-Z]+[0-9]+)*/g;
                        var id = $(editor).parents('.jexcel').parent('div').prop('id');
                        // 匹配出所有的参数
                        var elements = formula.match(regex).filter(function (n) { return n != '' });
                        // 先定义好颜色的顺序
                        var colorPalette = ["#0d6c54", "#c7983e", "#fb6929", "#b34f97", "#18a281", "#dbca34", "#b66b56", "#7a4271", "#446769", "#b7d02c", "#c6023a", "#cb7fb0", "#6c858c", "#ffb400", "#822f1d", "#bc69f7", "#1fcd92", "#918b3d", "#8b8b8b", "#875c89"];
                        $.each(elements, function (i, v) {
                            var cellId = $.fn.jexcel('getIdFromColumnName', v);
                            var cell = $('#' + id).find('#' + cellId);
                            // 如果是隐藏单元格则将父级单元格高亮
                            if ($(cell).hasClass('hide') && $(cell).data('merge')) {
                                cell = $('#' + id).find('#' + $(cell).data('merge'));
                            }
                            var formulaArea = document.createElement('div');
                            $(formulaArea).prop('class', 'formula-select-area');
                            $(formulaArea).css({
                                display: 'block',
                                'border-color': colorPalette[i],
                                width: $(cell).outerWidth() + 'px',
                                height: $(cell).outerHeight() + 'px',
                                top: $(cell).offset().top - 1 + 'px',
                                left: $(cell).offset().left - 1 + 'px'
                            });
                            $('.selection-board').append(formulaArea);
                        });
                    }
                }, 50);
            });
            $(editor).blur(function () {
                $('.formula-select-area').remove();
                var value = mask_exec($(this).val(), cellSet);
                $(editor).val(value);
            });
        }
    }
    $.fn.limsMask = Mask;
})(jQuery);

//由于js计算有bug，例如83.9792+83.9793=83.97925。但是在htmljs计算后，得出来的结果是:83.97925000000001为了解决这样的问题，增加了三个函数
/**
 ** 加法函数，用来得到精确的加法结果
 ** 说明：javascript的加法结果会有误差，在两个浮点数相加的时候会比较明显。这个函数返回较为精确的加法结果。
 ** 调用：accAdd(arg1,arg2)
 ** 返回值：arg1加上arg2的精确结果
 **/
function accAdd(arg1, arg2) {
    var r1, r2, m, c;
    try {
        r1 = arg1.toString().split(".")[1].length;
    } catch (e) {
        r1 = 0;
    }
    try {
        r2 = arg2.toString().split(".")[1].length;
    } catch (e) {
        r2 = 0;
    }
    c = Math.abs(r1 - r2);
    m = Math.pow(10, Math.max(r1, r2));
    if (c > 0) {
        var cm = Math.pow(10, c);
        if (r1 > r2) {
            arg1 = Number(arg1.toString().replace(".", ""));
            arg2 = Number(arg2.toString().replace(".", "")) * cm;
        } else {
            arg1 = Number(arg1.toString().replace(".", "")) * cm;
            arg2 = Number(arg2.toString().replace(".", ""));
        }
    } else {
        arg1 = Number(arg1.toString().replace(".", ""));
        arg2 = Number(arg2.toString().replace(".", ""));
    }
    return (arg1 + arg2) / m;
}
//给Number类型增加一个add方法，调用起来更加方便。
Number.prototype.add = function (arg) {
    return accAdd(arg, this);
};
/**
 ** 减法函数，用来得到精确的减法结果
 ** 说明：javascript的减法结果会有误差，在两个浮点数相减的时候会比较明显。这个函数返回较为精确的减法结果。
 ** 调用：accSub(arg1,arg2)
 ** 返回值：arg1加上arg2的精确结果
 **/
function accsub(arg1, arg2) {
    var r1, r2, m, n;
    try {
        r1 = arg1.toString().split(".")[1].length;
    } catch (e) {
        r1 = 0;
    }
    try {
        r2 = arg2.toString().split(".")[1].length;
    } catch (e) {
        r2 = 0;
    }
    m = Math.pow(10, Math.max(r1, r2)); //last modify by deeka //动态控制精度长度
    n = (r1 >= r2) ? r1 : r2;
    return ((arg1 * m - arg2 * m) / m).toFixed(n);
}
// 给Number类型增加一个mul方法，调用起来更加方便。
Number.prototype.sub = function (arg) {
    return accMul(arg, this);
};
/**
 ** 乘法函数，用来得到精确的乘法结果
 ** 说明：javascript的乘法结果会有误差，在两个浮点数相乘的时候会比较明显。这个函数返回较为精确的乘法结果。
 ** 调用：accMul(arg1,arg2)
 ** 返回值：arg1乘以 arg2的精确结果
 **/
function accMul(arg1, arg2) {
    var m = 0,
        s1 = arg1.toString(),
        s2 = arg2.toString();
    try {
        m += s1.split(".")[1].length;
    } catch (e) { }
    try {
        m += s2.split(".")[1].length;
    } catch (e) { }
    return Number(s1.replace(".", "")) * Number(s2.replace(".", "")) / Math.pow(10, m);
}
// 给Number类型增加一个mul方法，调用起来更加方便。
Number.prototype.mul = function (arg) {
    return accMul(arg, this);
};
/** 
 ** 除法函数，用来得到精确的除法结果
 ** 说明：javascript的除法结果会有误差，在两个浮点数相除的时候会比较明显。这个函数返回较为精确的除法结果。
 ** 调用：accDiv(arg1,arg2)
 ** 返回值：arg1除以arg2的精确结果
 **/
function accDiv(arg1, arg2) {
    return arg1 / arg2;
    // var t1 = 0,
    //     t2 = 0,
    //     r1, r2;
    // try {
    //     t1 = arg1.toString().split(".")[1].length;
    // } catch (e) { }
    // try {
    //     t2 = arg2.toString().split(".")[1].length;
    // } catch (e) { }
    // with (Math) {
    //     r1 = Number(arg1.toString().replace(".", ""));
    //     r2 = Number(arg2.toString().replace(".", ""));
    //     return (r1 / r2) * pow(10, t2 - t1);
    // }
}

//给Number类型增加一个div方法，调用起来更加方便。
Number.prototype.div = function (arg) {
    return accDiv(this, arg);
};
/*
1. 拟舍弃数字的最左一位数字小于5时则舍去，即保留的各位数字不变。
2.拟舍弃数字的最左一位数字大于5；或等于5，而其后跟有并非全部为0的数字时则进一即保留的末位数字加1。（指定“修约间隔”明确时，以指定位数为准。）
3.拟舍弃数字的最左一位数字等于5，而右面无数字或皆为0时，若所保留的末位数字为奇数则进一，为偶数（包含0）则舍弃。
4.四舍六入五单双！
*/
function roundjs(afloat, c) {
    var x = afloat;
    var y = c;
    x1 = accMul(x, Math.pow(10, y));
    x2 = Math.round(x1);
    if (Math.floor(x1) % 2 == 0) {
        s = x2 - x1;
        if (s == 0.5) {
            x2 = x2 - 1;
        }
    }
    result = accDiv(x2, Math.pow(10, y));
    s = result.toString();
    var rs = s.indexOf('.');
    if (rs < 0) {
        rs = s.length;
        if (y > 0) {
            s += '.';
        }
        for (i = 0; i < y; i++) {
            s += '0';
        }
    } else {
        r = y - (s.length - rs - 1);
        for (i = 0; i < r; i++) {
            s += '0';
        }
    }
    return s;
}
// 四舍五入函数
function round(aFloat, digits) {
    aFloat = String(Math.round(aFloat * Math.pow(10, digits)) / Math.pow(10, digits));
    temp = aFloat.split('.');
    if (temp.length == 1) {
        aFloat += '.';
        for (i = 0; i < digits; i++) {
            aFloat += '0';
        }
    } else {
        for (i = 0; i < digits - temp[1].length; i++) {
            aFloat += '0';
        }
    }
    return aFloat;
}
// 保留有效位数修约
function round_yxws(_num, decimals, max){
    var max = parseInt(max);
    var _num = parseFloat(_num);
    var decimals = parseInt(decimals);
    !$.isNumeric(max) && (max = 21);
    if(!$.isNumeric(_num) || !$.isNumeric(decimals)){
        return _num;
    }
    // decimals的范围必须是1-21,max最大也是21
    // (max < 1 || max > 21) && (max = 21);
    (Math.abs(decimals) > 21) && ( decimals = 0);
    // 强制保留固定小数位数,或者保留整数位
    if(max ==  0 || decimals == 0){
        return roundjs(_num, decimals);
    }
    // 整数部分的位数
    var z_num = _num.toString().split('.')[0].length;
    // 小数部分的位数
    var x_num = _num >= 0 ? 0 : _num.toString().split('.')[1].length;
    // 执行修约
    if(z_num >= Math.abs(decimals) || decimals < 0){
        // 处理负修约,即整数位修约
        // _num *= Math.pow(10, decimals);
        // var num = roundjs(_num, 0) / Math.pow(10, decimals);
        return roundjs(_num, 0);
    }else{
        // NumberObject.toPrecision(num)
        var num = _num.toPrecision(decimals + 2);
        num = roundjs(num, num.toString().split('.')[1].length - 2);
    }
    return num;
}
// 根据配置信息修约数据
function auto_round(num, set) {
    if ($.isNumeric(set)) {
        set = {
            blws: [[0, set]]
        };
    } else {
        var set_default = {
            version: '1.0',
            xiuyue_jiange: 1,
            round_function: 'roundjs',
            round_type: 'yxws',
            max_num: 10,
            blws: [[0, 2]]
        }
        set = $.extend(set_default, set);
    }
    for (var i = 0; i < set.blws.length; i++) {
        if (!$.isNumeric(set.blws[i][0]) || !$.isNumeric(set.blws[i][1])) {
            continue;
        }
        if (Math.abs(num) >= set.blws[i][0]) {
            num = roundjs(num, set.blws[i][1]);
        }
    }
    return num;
}

function round_hyd_vd0(_num, lineIndex, cellId) {
    console.log('原始值：', _num);
    if (!$.isNumeric(_num)) {
        return _num;
    } else {
        var num = '';
        _num = parseFloat(_num);
    }
    var set = {
        blws: [],
        max_num: 10
    };
    // 必须含有化验单数据数组
    if(!arowData || !arowData['id']){
        return _num;
    }
    if (arowData['blws']) {
        try {
            var blws = eval(arowData['blws']);
            if(!blws && !blws.length){
                blws = [];
            }
            $.each(blws, function (k, v) {
                $.isNumeric(v[0]) || (v[0] = 0);
                $.isNumeric(v[1]) || (v[1] = 2);
                $.isNumeric(v[2]) || (v[2] = 2);
                if (_num >= v[0]) {
                    num = round_yxws(_num, v[1], v[2]);
                    return false;
                }
            })
        } catch (e) {
            console.log(e)
        }
    } else {
        if (_num < 1) {
            num = !$.isNumeric(arowData['w1']) ? _num : roundjs(_num, arowData['w1']);
        } else if (_num < 10 && _num >= 1) {
            num = !$.isNumeric(arowData['w2']) ? _num : roundjs(_num, arowData['w2']);
        } else if (_num < 100 && _num >= 10) {
            num = !$.isNumeric(arowData['w3']) ? _num : roundjs(_num, arowData['w3']);
        } else if (_num < 1000 && _num >= 100) {
            num = !$.isNumeric(arowData['w4']) ? _num : roundjs(_num, arowData['w4']);
        } else {
            num = !$.isNumeric(arowData['w5']) ? _num : roundjs(_num, arowData['w5']);
        }
    }
    //使用哪个值进行检出限判断，_vd0表示先判定检出限再修约，vd0表示先修约再判定
    check_value = (trade_global['hyd_config'] && 'vd0' == trade_global['hyd_config']['check_jcx_with_value']) ? num : _num;
    if ('-' == arowData['td3'] && parseFloat(check_value) == 0) {
        num = '未检出';
    } else if (parseFloat(arowData['td3']) > 0 && check_value < parseFloat(arowData['td3'])) {
        num = '<' + arowData['td3'];
    }
    // 记录原始结果
    // 当仪器载入时，vd0的结果需要在加载的时候自动进行修约存入post_data
    if(!window.post_data){
        window.post_data = {
            'vd0': [],
            '_vd0': []
        };
    }
    // 重新复制原始值和修约后的结果
    window.post_data['vd0'][lineIndex] = num;
    window.post_data['_vd0'][lineIndex] = _num;
    console.log('---', num, _num)
    if(window.immTableSheet && window.immTableSheet.div){
        var title = $.isNumeric(_num) ? '原始结果:' + _num : '原始结果:error';
        $(immTableSheet.div).find('td[id=' + cellId + ']').prop('title', title);
    }
    console.log(window.post_data)
    return num;
}
/**
 * 功能：计算位数修约
 * 作者：
 * 日期：2014-10-25
 * 参数：vd0 float 计算的原始结果
 * 参数：wsint 可选参数，保留位数
 * 返回值：vd0 float修约后的位数
 * 功能描述： 此修约并不是最终修约，而是为了避免计算结果的位数过长而设置的统一修约函数
*/
function jsws(vd0) {
    var ws = arguments[1] ? arguments[1] : 8;
    if (!$.isNumeric(vd0)) {
        return '';
    } else {
        var r = vd0.toString().split('.');
        if (r.length == 2 && r[1].length > ws) {
            return roundjs(parseFloat(vd0), ws);
        } else {
            return parseFloat(vd0);
        }
    }
}